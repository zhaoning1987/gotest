func DownloadFile(ctx context.Context, c *rpc.Client, url string) (content []byte, err error) {
	req, err := http.NewRequest("GET", url, nil)
	resp, err := c.Do(ctx, req)
	if err != nil {
		return nil, errors.Wrapf(err, fmt.Sprintf("error when trying to get image: %s", url))
	}
	defer resp.Body.Close()

	if resp.StatusCode/100 != 2 {
		return nil, errors.Errorf("failed to get image, response status code : %d", resp.StatusCode)
	}

	content, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, errors.Wrapf(err, fmt.Sprintf("error when trying to read the content of image : %s", url))
	}
	return content, nil
}


	fj.imageContent, err = util.DownloadFile(fj.ctx, fj.distributor.client, string(fj.imageURI))
	if err != nil {
		xl.Errorf("%s : %s\n", fj.imageURI, err)
		if err := fj.distributor.UpdateErrorLog(string(fj.imageURI), proto.ErrFectchImage); err != nil {
			xl.Errorf("distributor.UpdateErrorLog fail: %s", err)
		}
	}




	if config.PosPitch, err = proto.GetValidPosLimit(env.Req.FormValue("pos_pitch")); err != nil {
		return nil, proto.ErrInvalidPosPitch
	}

	if config.PosYaw, err = proto.GetValidPosLimit(env.Req.FormValue("pos_yaw")); err != nil {
		return nil, proto.ErrInvalidPosYaw
	}

	if config.PosRol, err = proto.GetValidPosLimit(env.Req.FormValue("pos_rol")); err != nil {
		return nil, proto.ErrInvalidPosRol
	}

	if config.Width, err = proto.GetValidSizeLimit(env.Req.FormValue("width")); err != nil {
		return nil, proto.ErrInvalidWidth
	}

	if config.Height, err = proto.GetValidSizeLimit(env.Req.FormValue("height")); err != nil {
		return nil, proto.ErrInvalidHeight
	}

	if config.Mode, err = proto.GetValidMode(env.Req.FormValue("mode")); err != nil {
		return nil, proto.ErrInvalidMode
	}



func GetValidPosLimit(s string) (PosLimit, error) {
	if s == "" {
		return 0, nil
	}
	limit, err := strconv.Atoi(s)
	if err != nil {
		return 0, errors.New("pos limit is not a number")
	}
	if limit <= 0 || limit > 90 {
		return 0, errors.New("pos limit exceed")
	}
	return PosLimit(limit), nil
}

func GetValidSizeLimit(s string) (SizeLimit, error) {
	if s == "" {
		return 0, nil
	}
	limit, err := strconv.Atoi(s)
	if err != nil {
		return 0, errors.New("size limit is not a number")
	}
	if limit <= 0 {
		return 0, errors.New("size limit exceed")
	}
	return SizeLimit(limit), nil
}

func GetValidMode(s string) (Mode, error) {
	if s == "" {
		return MEET_ERROR_NON_STOP, nil
	}
	mode, err := strconv.Atoi(s)
	if err != nil {
		return 0, errors.New("mode is not a number")
	}
	if mode != int(MEET_ERROR_NON_STOP) && mode != int(MEET_ERROR_STOP) {
		return 0, errors.New("invalid mode")
	}
	return Mode(mode), nil
}




	ErrInvalidPosPitch      = httputil.NewError(http.StatusBadRequest, "pos_pitch is invalid, should be positive number from 1 to 90")
	ErrInvalidPosYaw        = httputil.NewError(http.StatusBadRequest, "pos_yaw is invalid, should be positive number from 1 to 90")
	ErrInvalidPosRol        = httputil.NewError(http.StatusBadRequest, "pos_rol is invalid, should be positive number from 1 to 90")



	PosPitch      PosLimit `json:"pos_pitch" bson:"pos_pitch"`
	PosYaw        PosLimit `json:"pos_yaw" bson:"pos_yaw"`
	PosRol        PosLimit `json:"pos_rol" bson:"pos_rol"`




请求字段说明：

| 字段               | 取值   | 说明                     |
| :----------------  | :----- | :----------------------- |
| group_name         | string    | 任务所属的人脸库group名，必选|
| pos_pitch          | string    | 允许的人脸最大俯仰角，超过则该人脸不会入库，可选，取值为[1, 90], 默认为空（即不限制） |
| pos_yaw            | string    | 允许的人脸最大偏航角，超过该值则该人脸不会入库，可选，取值为[1, 90], 默认为空（即不限制） |
| pos_rol            | string    | 允许的人脸最大翻滚角，超过该值则该人脸不会入库，可选，取值为[1, 90], 默认为空（即不限制） |
| width              | string    | 允许的人脸最小宽度，低于该值则该人脸不会入库，可选，取值为大于0的整数，默认为空（即不限制） |
| height             | string    | 允许的人脸最小高度，低于该值则该人脸不会入库，可选，取值为大于0的整数，默认为空（即不限制） |
| mode               | string    | 入库时遇见错误图片时的处理方式，0为跳过继续执行，1为将任务停止，可选，默认为0 |
| file               | string    | 表单提交的csv文件，必选 |